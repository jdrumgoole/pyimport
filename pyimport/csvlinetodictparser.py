
from datetime   import datetime
import csv
from enum import Enum
import logging
from typing import List, Callable

from pyimport.fieldfile import FieldFile
from pyimport.type_converter import Converter
from pyimport.doctimestamp import DocTimeStamp


class ErrorResponse(Enum):
    Ignore = "ignore"
    Warn   = "warn"
    Fail   = "fail"

    def __str__(self):
        return self.value


class CSVLineToDictParser:

    def __init__(self,
                 field_file: FieldFile,
                 locator: bool = True,
                 timestamp_func: Callable = None,
                 onerror: ErrorResponse = ErrorResponse.Warn):

        self._logger = logging.getLogger(__name__)

        self._onerror = onerror
        self._record_count = 0
        self._line_count = 0
        self._timestamp = None
        self._idField = None  # section on which filename == _id
        self._log = logging.getLogger(__name__)
        self._converter = Converter(self._log)
        self._field_file = field_file
        self._locator = locator
        if timestamp_func is None:
            self._timestamp_func = lambda d : d
        else:
            self._timestamp_func = timestamp_func

    def parse_line(self, csv_line: List[str], line_number: int) -> dict:
        """
        Make a new doc from a dictEntry generated by the csv.DictReader.

        :param csv_line: the line to be parsed (list of strs)
        :param line_number: the location of the line in the input file
        :return: the new doc

        WIP
        Do we make gen id generate a compound key or another field instead of ID
        """

        fields = self._field_file.fields()

        if len(csv_line) == 1:
            self._logger.warning("Warning: only one field in "
                                 "input line. Do you have the "
                                 "right delimiter set ?")
            self._logger.warning(f"input line : {csv_line}")

        if len(csv_line) != len(fields):
            raise ValueError(f"\nrecord: at line {line_number}:{csv_line}(len={len(csv_line)}) and fields required\n"
                             f"{self._field_file.fields()}(len={len(fields)})"
                             f"don't match in length")

        doc = dict(zip(fields, csv_line))

        # print( "dictEntry: %s" % dictEntry )
        field_count = 0

        new_doc = {}

        for k, v in doc.items():
            # print( "field: %s" % k )
            # print( "value: %s" % dictEntry[ k ])
            field_count = field_count + 1

            if v is None:
                msg = f"Value for field '{k}' at line {line_number} is '{v}' which is not valid\n"
                # print(dictEntry)
                msg = msg + f"\t\t\tline:{line_number}:'{csv_line}'"
                if self._onerror == ErrorResponse.Fail:
                    if self._log:
                        self._log.error(msg)
                    raise ValueError(msg)
                elif self._onerror == ErrorResponse.Warn:
                    if self._log:
                        self._log.warning(msg)
                    continue
                else:
                    continue

            if k.startswith("blank-") and self._onerror == ErrorResponse.Warn:  # ignore blank- columns
                if self._log:
                    self._log.info(f"Field {field_count} is blank [blank-] : ignoring")
                continue

            # try:
            try:
                type_field = self._field_file.type_value(k)
                if type_field in ["date", "datetime"]:
                    fmt = self._field_file.format_value(k)
                    new_doc[k] = self._converter.convert_time(type_field, v, fmt, line_number, ','.join(csv_line))
                elif type_field == "isodate":
                    new_doc[k] = self._converter.convert_time(type_field, v, None, line_number, ','.join(csv_line))
                else:
                    new_doc[k] = self._converter.convert(type_field, v)

            except ValueError:
                if self._onerror == ErrorResponse.Fail:
                    if self._log:
                        self._log.error(f"Error at line {self._record_count} at field '{k}'"
                                        f"type conversion error: Cannot convert '{v}' to type {type_field}")
                    raise
                elif self._onerror == ErrorResponse.Warn:
                    self._log.warning(f"Parse failure at line {self._record_count} at field '{k}' type conversion "
                                      f"error: Cannot convert '{v}' to type {type_field} using string type instead")
                    new_doc[k] = str(v)
                elif self._onerror == ErrorResponse.Ignore:
                    new_doc[k] = str(v)
                else:
                    raise ValueError(f"Invalid value for onerror: {self._onerror}")

            if self._field_file.has_new_name(k):
                #assert (self._field_file.name_value(k) is not None)
                new_doc[self._field_file.name_value(k)] = new_doc.pop(k)

            if self._locator:
                new_doc['locator'] = {"line": line_number}

            new_doc = self._timestamp_func(new_doc)

        return new_doc
