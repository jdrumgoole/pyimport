import logging
from typing import Callable, Tuple

from pyimport.fieldfile import FieldFile
from pyimport.logger import ErrorResponse, ErrorHandler
from pyimport.type_converter import convert_it


class EnricherException(Exception):
    pass


class Enricher:

    def __init__(self,
                 field_file: FieldFile,
                 locator: bool = True,
                 timestamp_func: Callable = None,
                 onerror: ErrorResponse = ErrorResponse.Warn,
                 filename: str = None):

        self._logger = logging.getLogger(__name__)

        self._onerror = onerror
        self._eh = ErrorHandler(onerror)
        self._line_count = 0
        self._timestamp = None
        self._idField = None  # section on which filename == _id
        self._log = logging.getLogger(__name__)
        #self._converter = Converter(self._log)
        self._field_file = field_file
        self._locator = locator
        self._timestamp_func = timestamp_func
        if filename is None:
            self._filename = "Unknown"
        else:
            self._filename = filename

    def enrich_value(self, k, v) -> str:

        if k.startswith("blank-"):
            self._eh.warning(f"Field {k} is blank [blank-] : ignoring")
            return None
        # try:
        t = self._field_file.type_value(k)

        try:
            return convert_it(t, v, self._field_file.format_value(k))

        except ValueError as e:
            self._eh.error(f"Parse failure at field '{k}'\ntype conversion error: Cannot convert '{v}' to type {t}")

    def enrich_doc(self, csv_doc: dict, new_field: Tuple[str, str]=None, line_number: int = None) -> dict:
        """
        Make a new doc from a dictEntry generated by the csv.DictReader.

        :param csv_doc: the line to be parsed (dict of strs)
        :param new_field: a tuple of a new field and value to be added to the doc
        :param line_number: the location of the line in the input file
        :return: the new doc

        WIP
        Do we make gen id generate a compound key or another field instead of ID
        TODO: Need to get the filename being parsed in at this level to allow use to report the right fil
        when an error occurs.
        """
        if line_number is None:
            line_number = "Unknown"

        fields = self._field_file.fields()
        len_csv_doc = len(csv_doc)

        if len_csv_doc == 1:
            line = ",".join(csv_doc.values())
            self._eh.warning(f"Warning: only one field in input line. Do you have the right delimiter set ?")
            self._eh.warning(f"input line : {line}")

        if len_csv_doc != len(self._field_file):
            self._eh.fatal(f"\nrecord: at line {line_number}:{line}(len={len_csv_doc}) and fields required\n"
                           f"{fields}(len={len(fields)} don't match in length")

        new_doc: dict = {k: self.enrich_value(k, v) for k, v in csv_doc.items()}

        if self._locator:
            new_doc['locator'] = {"line": line_number}

        if new_field and new_field not in new_doc:
            new_doc[new_field[0]] = new_field[1]

        return self._timestamp_func(new_doc) if self._timestamp_func else new_doc


