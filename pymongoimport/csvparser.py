

from datetime   import datetime
import csv
from enum import Enum
import logging

from pymongoimport.configfile import ConfigFile
from pymongoimport.type_converter import Converter


class ErrorResponse(Enum):
    Ignore = 0
    Warn   = 1
    Fail   = 2


class CSVParser:

    def __init__(self,
                 config_file : ConfigFile,
                 hasheader: bool = "False",
                 delimiter:str = ",",
                 onerror: ErrorResponse = ErrorResponse.Warn):

        self._delimiter = delimiter
        self._hasheader = hasheader
        self._onerror = onerror
        self._record_count = 0
        self._line_count = 0
        self._timestamp = None
        self._idField = None  # section on which name == _id
        self._log = logging.getLogger(__name__)
        self._converter = Converter(self._log)
        self._config = config_file

    # def add_timestamp(self, timestamp):
    #     '''
    #     timestamp = "now" generate time once for all docs
    #     timestamp = "gen" generate a new timestamp for each doc
    #     timestamp = "none" don't add timestamp field
    #     '''
    #     self._timestamp = timestamp
    #     if timestamp == "now":
    #         self._doc_template["timestamp"] = datetime.utcnow()
    #     return self._doc_template

    def hasheader(self):
        return self._hasheader

    def delimiter(self):
        return self._delimiter

    def get_dict_reader(self, f):
        if self._delimiter == "tab":
            self._delimiter = "\t"
        return csv.DictReader(f, fieldnames=self._config.fields(), delimiter=self._delimiter)

    def createDoc(self, dictEntry):
        """
        Make a new doc from a dictEntry generated by the csv.DictReader.

        :param dictEntry: the corresponding dictEntry for the column
        :return: the new doc

        WIP
        Do we make gen id generate a compound key or another field instead of ID
        """

        doc = {}

        self._record_count = self._record_count + 1

        if self._timestamp == "gen":
            doc['timestamp'] = datetime.utcnow()

        # print( "dictEntry: %s" % dictEntry )
        fieldCount = 0
        for k in self._config.fields():
            # print( "field: %s" % k )
            # print( "value: %s" % dictEntry[ k ])
            fieldCount = fieldCount + 1

            if dictEntry[k] is None:
                if self._hasheader:
                    self._line_count = self._record_count + 1
                else:
                    self._line_count = self._record_count

                msg = "Value for field '{}' at line {} is 'None' which is not valid\n".format(k, self._line_count)
                # print(dictEntry)
                msg = msg + "\t\t\tline:{}:'{}'".format(self._record_count,
                                                        self._delimiter.join([str(v) for v in dictEntry.values()]))
                if self._onerror == ErrorResponse.Fail:
                    if self._log:
                        self._log.error(msg)
                    raise ValueError(msg)
                elif self._onerror == ErrorResponse.Warn:
                    if self._log:
                        self._log.warning(msg)
                    continue
                else:
                    continue

            if k.startswith("blank-") and self._onerror == ErrorResponse.Warn:  # ignore blank- columns
                if self._log:
                    self._log.info("Field %i is blank [blank-] : ignoring", fieldCount)
                continue

            # try:
            try:
                type_field = self._config.type_value(k)
                if type_field in ["date", "datetime"]:
                    format = self._config.format_value(k)
                    v = self._converter.convert_time(type_field, dictEntry[k], format)
                else:
                    v = self._converter.convert(type_field, dictEntry[k])

            except ValueError:

                if self._onerror == ErrorResponse.Fail:
                    if self._log:
                        self._log.error("Error at line %i at field '%s'", self._record_count, k)
                        self._log.error("type conversion error: Cannot convert '%s' to type %s", dictEntry[k],
                                        type_field)
                    raise
                elif self._onerror == ErrorResponse.Warn:
                    msg = "Parse failure at line {} at field '{}'".format(self._record_count, k)
                    msg = msg + " type conversion error: Cannot convert '{}' to type {} using string type instead".format(
                        dictEntry[k], type_field)
                    v = str(dictEntry[k])
                elif self._onerror == ErrorResponse.Ignore:
                    v = str(dictEntry[k])
                else:
                    raise ValueError("Invalid value for onerror: %s" % self._onerror)

            if self._config.hasNewName(k):
                assert (self._config.name_value(k) != None)
                doc[self._config.name_value(k)] = v
            else:
                doc[k] = v

        #             except ValueError :
        #                 self._log.error( "Value error parsing field : [%s]" , k )
        #                 self._log.error( "read value is: '%s'", dictEntry[ k ] )
        #                 self._log.error( "line: %i, '%s'", self._record_count, dictEntry )
        #                 #print( "ValueError parsing filed : %s with value : %s (type of field: $s) " % ( str(k), str(line[ k ]), str(fieldDict[ k]["type"])))
        #                 raise

        return doc
